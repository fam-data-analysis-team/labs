Порівняємо різні нелінійні ефекти за значенням R adjusted 

```{r}
library(dplyr)
library(boot)
library(readr)
library(knitr)
library(tibble)
library(ggplot2)
library(stringr)
library(tidyr)
library(forcats)
library(here)

df <- readRDS(here("data", "processed", "air_quality_trimmed.rds"))
```

```{r}
calc_r_score <- function (f, filter, var) {
  xy <- tibble(x = df[[var]], y = df$aqi) %>% na.omit() %>% filter()

  y <- xy$y
  x <- xy$x

  model <- lm(y ~ I(f(x)))

  return (summary(model)$adj.r.squared)
}

fs <- list(
  c(\(x) x, \(t) t), 
  c(\(x) log(x), \(t) t[t$x > 0, ]), 
  c(\(x) x + x^2, \(t) t)
)
vars <- c("pm2.5", "pm10", "o3", "so2", "co")

table <- lapply(vars, 
  \(var) lapply(fs, 
    \(f) calc_r_score(f[[1]], f[[2]], var)
  )
) 
table <- do.call(rbind, table)

colnames(table) <- c("x", "log(x)", "x + x^2")
rownames(table) <- vars

print(table)
```

Згідно результатів таблиці будемо використовувати такі перетворення (де більше R^2, тим якісніше прогнозні значення збігаються з даними):

- pm2.5
- pm10
- o3 + o3^2
- log(so2)
- log(co)
